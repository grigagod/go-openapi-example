//go:build go1.22

// Package oas provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package oas

import (
	"bytes"
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2Scopes = "OAuth2.Scopes"
)

// Defines values for BookingPaymentCurrency.
const (
	Bam BookingPaymentCurrency = "bam"
	Bgn BookingPaymentCurrency = "bgn"
	Chf BookingPaymentCurrency = "chf"
	Eur BookingPaymentCurrency = "eur"
	Gbp BookingPaymentCurrency = "gbp"
	Nok BookingPaymentCurrency = "nok"
	Sek BookingPaymentCurrency = "sek"
	Try BookingPaymentCurrency = "try"
)

// Defines values for BookingPaymentSource1AccountType.
const (
	Company    BookingPaymentSource1AccountType = "company"
	Individual BookingPaymentSource1AccountType = "individual"
)

// Defines values for BookingPaymentStatus.
const (
	Failed    BookingPaymentStatus = "failed"
	Pending   BookingPaymentStatus = "pending"
	Succeeded BookingPaymentStatus = "succeeded"
)

// Booking defines model for Booking.
type Booking struct {
	// HasBicycle Indicates whether the passenger has a bicycle.
	HasBicycle *bool `json:"has_bicycle,omitempty"`

	// HasDog Indicates whether the passenger has a dog.
	HasDog *bool `json:"has_dog,omitempty"`

	// Id Unique identifier for the booking
	Id *openapi_types.UUID `json:"id,omitempty"`

	// PassengerName Name of the passenger
	PassengerName *string `json:"passenger_name,omitempty"`

	// TripId Identifier of the booked trip
	TripId *openapi_types.UUID `json:"trip_id,omitempty"`
}

// BookingPayment defines model for BookingPayment.
type BookingPayment struct {
	// Amount Amount intended to be collected by this payment. A positive decimal figure describing the amount to be collected.
	Amount *float32 `json:"amount,omitempty"`

	// Currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
	Currency *BookingPaymentCurrency `json:"currency,omitempty"`

	// Id Unique identifier for the payment. This will be a unique identifier for the payment, and is used to reference the payment in other objects.
	Id    *openapi_types.UUID `json:"id,omitempty"`
	Links *LinksBooking       `json:"links,omitempty"`

	// Source The payment source to take the payment from. This can be a card or a bank account. Some of these properties will be hidden on read to protect PII leaking.
	Source *BookingPayment_Source `json:"source,omitempty"`

	// Status The status of the payment, one of `pending`, `succeeded`, or `failed`.
	Status *BookingPaymentStatus `json:"status,omitempty"`
}

// BookingPaymentCurrency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
type BookingPaymentCurrency string

// BookingPaymentSource0 A card (debit or credit) to take payment from.
type BookingPaymentSource0 struct {
	AddressCity     *string `json:"address_city,omitempty"`
	AddressCountry  string  `json:"address_country"`
	AddressLine1    *string `json:"address_line1,omitempty"`
	AddressLine2    *string `json:"address_line2,omitempty"`
	AddressPostCode *string `json:"address_post_code,omitempty"`

	// Cvc Card security code, 3 or 4 digits usually found on the back of the card.
	Cvc *string `json:"cvc,omitempty"`

	// ExpMonth Two-digit number representing the card's expiration month.
	ExpMonth int64 `json:"exp_month"`

	// ExpYear Four-digit number representing the card's expiration year.
	ExpYear int64 `json:"exp_year"`

	// Name Cardholder's full name as it appears on the card.
	Name string `json:"name"`

	// Number The card number, as a string without any separators. On read all but the last four digits will be masked for security.
	Number string  `json:"number"`
	Object *string `json:"object,omitempty"`
}

// BookingPaymentSource1 A bank account to take payment from. Must be able to make payments in the currency specified in the payment.
type BookingPaymentSource1 struct {
	// AccountType The type of entity that holds the account. This can be either `individual` or `company`.
	AccountType BookingPaymentSource1AccountType `json:"account_type"`

	// BankName The name of the bank associated with the routing number.
	BankName string `json:"bank_name"`

	// Country Two-letter country code (ISO 3166-1 alpha-2).
	Country string `json:"country"`
	Name    string `json:"name"`

	// Number The account number for the bank account, in string form. Must be a current account.
	Number string  `json:"number"`
	Object *string `json:"object,omitempty"`

	// SortCode The sort code for the bank account, in string form. Must be a six-digit number.
	SortCode *string `json:"sort_code,omitempty"`
}

// BookingPaymentSource1AccountType The type of entity that holds the account. This can be either `individual` or `company`.
type BookingPaymentSource1AccountType string

// BookingPayment_Source The payment source to take the payment from. This can be a card or a bank account. Some of these properties will be hidden on read to protect PII leaking.
type BookingPayment_Source struct {
	union json.RawMessage
}

// BookingPaymentStatus The status of the payment, one of `pending`, `succeeded`, or `failed`.
type BookingPaymentStatus string

// LinksBooking defines model for Links-Booking.
type LinksBooking struct {
	Booking *string `json:"booking,omitempty"`
}

// LinksDestination The link to the destination station resource.
type LinksDestination struct {
	Self *string `json:"self,omitempty"`
}

// LinksOrigin The link to the origin station resource.
type LinksOrigin struct {
	Self *string `json:"self,omitempty"`
}

// LinksPagination defines model for Links-Pagination.
type LinksPagination struct {
	Next *string `json:"next,omitempty"`
	Prev *string `json:"prev,omitempty"`
}

// LinksSelf defines model for Links-Self.
type LinksSelf struct {
	Self *string `json:"self,omitempty"`
}

// Problem defines model for Problem.
type Problem struct {
	// Detail A human-readable explanation specific to this occurrence of the problem
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code
	Status *int `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem type
	Title *string `json:"title,omitempty"`

	// Type A URI reference that identifies the problem type
	Type *string `json:"type,omitempty"`
}

// Station defines model for Station.
type Station struct {
	// Address The address of the station.
	Address string `json:"address"`

	// CountryCode The country code of the station.
	CountryCode string `json:"country_code"`

	// Id Unique identifier for the station.
	Id openapi_types.UUID `json:"id"`

	// Name The name of the station
	Name string `json:"name"`

	// Timezone The timezone of the station in the [IANA Time Zone Database format](https://www.iana.org/time-zones).
	Timezone *string `json:"timezone,omitempty"`
}

// Trip defines model for Trip.
type Trip struct {
	// ArrivalTime The date and time when the trip arrives
	ArrivalTime *time.Time `json:"arrival_time,omitempty"`

	// BicyclesAllowed Indicates whether bicycles are allowed on the trip
	BicyclesAllowed *bool `json:"bicycles_allowed,omitempty"`

	// DepartureTime The date and time when the trip departs
	DepartureTime *time.Time `json:"departure_time,omitempty"`

	// Destination The destination station of the trip
	Destination *string `json:"destination,omitempty"`

	// DogsAllowed Indicates whether dogs are allowed on the trip
	DogsAllowed *bool `json:"dogs_allowed,omitempty"`

	// Id Unique identifier for the trip
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Operator The name of the operator of the trip
	Operator *string `json:"operator,omitempty"`

	// Origin The starting station of the trip
	Origin *string `json:"origin,omitempty"`

	// Price The cost of the trip
	Price *float32 `json:"price,omitempty"`
}

// WrapperCollection This is a generic request/response wrapper which contains both data and links which serve as hypermedia controls (HATEOAS).
type WrapperCollection struct {
	// Data The wrapper for a collection is an array of objects.
	Data *[]map[string]interface{} `json:"data,omitempty"`

	// Links A set of hypermedia links which serve as controls for the client.
	Links *map[string]interface{} `json:"links,omitempty"`
}

// Limit defines model for limit.
type Limit = int

// Page defines model for page.
type Page = int

// BadRequest defines model for BadRequest.
type BadRequest = Problem

// Conflict defines model for Conflict.
type Conflict = Problem

// Forbidden defines model for Forbidden.
type Forbidden = Problem

// InternalServerError defines model for InternalServerError.
type InternalServerError = Problem

// NotFound defines model for NotFound.
type NotFound = Problem

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = Problem

// Unauthorized defines model for Unauthorized.
type Unauthorized = Problem

// GetBookingsParams defines parameters for GetBookings.
type GetBookingsParams struct {
	// Page The page number to return
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit The number of items to return per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetStationsParams defines parameters for GetStations.
type GetStationsParams struct {
	// Page The page number to return
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit The number of items to return per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Coordinates The latitude and longitude of the user's location, to narrow down the search results to sites within a proximity of this location.
	Coordinates *string `form:"coordinates,omitempty" json:"coordinates,omitempty"`

	// Search A search term to filter the list of stations by name or address.
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Country Filter stations by country code
	Country *string `form:"country,omitempty" json:"country,omitempty"`
}

// GetTripsParams defines parameters for GetTrips.
type GetTripsParams struct {
	// Page The page number to return
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit The number of items to return per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Origin The ID of the origin station
	Origin openapi_types.UUID `form:"origin" json:"origin"`

	// Destination The ID of the destination station
	Destination openapi_types.UUID `form:"destination" json:"destination"`

	// Date The date and time of the trip in ISO 8601 format in origin station's timezone.
	Date time.Time `form:"date" json:"date"`

	// Bicycles Only return trips where bicycles are known to be allowed
	Bicycles *bool `form:"bicycles,omitempty" json:"bicycles,omitempty"`

	// Dogs Only return trips where dogs are known to be allowed
	Dogs *bool `form:"dogs,omitempty" json:"dogs,omitempty"`
}

// CreateBookingJSONRequestBody defines body for CreateBooking for application/json ContentType.
type CreateBookingJSONRequestBody = Booking

// CreateBookingPaymentJSONRequestBody defines body for CreateBookingPayment for application/json ContentType.
type CreateBookingPaymentJSONRequestBody = BookingPayment

// AsBookingPaymentSource0 returns the union data inside the BookingPayment_Source as a BookingPaymentSource0
func (t BookingPayment_Source) AsBookingPaymentSource0() (BookingPaymentSource0, error) {
	var body BookingPaymentSource0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBookingPaymentSource0 overwrites any union data inside the BookingPayment_Source as the provided BookingPaymentSource0
func (t *BookingPayment_Source) FromBookingPaymentSource0(v BookingPaymentSource0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBookingPaymentSource0 performs a merge with any union data inside the BookingPayment_Source, using the provided BookingPaymentSource0
func (t *BookingPayment_Source) MergeBookingPaymentSource0(v BookingPaymentSource0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBookingPaymentSource1 returns the union data inside the BookingPayment_Source as a BookingPaymentSource1
func (t BookingPayment_Source) AsBookingPaymentSource1() (BookingPaymentSource1, error) {
	var body BookingPaymentSource1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBookingPaymentSource1 overwrites any union data inside the BookingPayment_Source as the provided BookingPaymentSource1
func (t *BookingPayment_Source) FromBookingPaymentSource1(v BookingPaymentSource1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBookingPaymentSource1 performs a merge with any union data inside the BookingPayment_Source, using the provided BookingPaymentSource1
func (t *BookingPayment_Source) MergeBookingPaymentSource1(v BookingPaymentSource1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BookingPayment_Source) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BookingPayment_Source) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetBookings request
	GetBookings(ctx context.Context, params *GetBookingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBookingWithBody request with any body
	CreateBookingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBooking(ctx context.Context, body CreateBookingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBooking request
	DeleteBooking(ctx context.Context, bookingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBooking request
	GetBooking(ctx context.Context, bookingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBookingPaymentWithBody request with any body
	CreateBookingPaymentWithBody(ctx context.Context, bookingId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBookingPayment(ctx context.Context, bookingId openapi_types.UUID, body CreateBookingPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStations request
	GetStations(ctx context.Context, params *GetStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTrips request
	GetTrips(ctx context.Context, params *GetTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetBookings(ctx context.Context, params *GetBookingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBookingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBookingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBooking(ctx context.Context, body CreateBookingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBookingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBooking(ctx context.Context, bookingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBookingRequest(c.Server, bookingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBooking(ctx context.Context, bookingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBookingRequest(c.Server, bookingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBookingPaymentWithBody(ctx context.Context, bookingId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBookingPaymentRequestWithBody(c.Server, bookingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBookingPayment(ctx context.Context, bookingId openapi_types.UUID, body CreateBookingPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBookingPaymentRequest(c.Server, bookingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStations(ctx context.Context, params *GetStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrips(ctx context.Context, params *GetTripsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTripsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetBookingsRequest generates requests for GetBookings
func NewGetBookingsRequest(server string, params *GetBookingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBookingRequest calls the generic CreateBooking builder with application/json body
func NewCreateBookingRequest(server string, body CreateBookingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBookingRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBookingRequestWithBody generates requests for CreateBooking with any type of body
func NewCreateBookingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBookingRequest generates requests for DeleteBooking
func NewDeleteBookingRequest(server string, bookingId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookingId", runtime.ParamLocationPath, bookingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBookingRequest generates requests for GetBooking
func NewGetBookingRequest(server string, bookingId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookingId", runtime.ParamLocationPath, bookingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBookingPaymentRequest calls the generic CreateBookingPayment builder with application/json body
func NewCreateBookingPaymentRequest(server string, bookingId openapi_types.UUID, body CreateBookingPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBookingPaymentRequestWithBody(server, bookingId, "application/json", bodyReader)
}

// NewCreateBookingPaymentRequestWithBody generates requests for CreateBookingPayment with any type of body
func NewCreateBookingPaymentRequestWithBody(server string, bookingId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookingId", runtime.ParamLocationPath, bookingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookings/%s/payment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStationsRequest generates requests for GetStations
func NewGetStationsRequest(server string, params *GetStationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Coordinates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "coordinates", runtime.ParamLocationQuery, *params.Coordinates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Country != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country", runtime.ParamLocationQuery, *params.Country); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTripsRequest generates requests for GetTrips
func NewGetTripsRequest(server string, params *GetTripsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "origin", runtime.ParamLocationQuery, params.Origin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destination", runtime.ParamLocationQuery, params.Destination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Bicycles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bicycles", runtime.ParamLocationQuery, *params.Bicycles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Dogs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dogs", runtime.ParamLocationQuery, *params.Dogs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetBookingsWithResponse request
	GetBookingsWithResponse(ctx context.Context, params *GetBookingsParams, reqEditors ...RequestEditorFn) (*GetBookingsResponse, error)

	// CreateBookingWithBodyWithResponse request with any body
	CreateBookingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBookingResponse, error)

	CreateBookingWithResponse(ctx context.Context, body CreateBookingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBookingResponse, error)

	// DeleteBookingWithResponse request
	DeleteBookingWithResponse(ctx context.Context, bookingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteBookingResponse, error)

	// GetBookingWithResponse request
	GetBookingWithResponse(ctx context.Context, bookingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetBookingResponse, error)

	// CreateBookingPaymentWithBodyWithResponse request with any body
	CreateBookingPaymentWithBodyWithResponse(ctx context.Context, bookingId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBookingPaymentResponse, error)

	CreateBookingPaymentWithResponse(ctx context.Context, bookingId openapi_types.UUID, body CreateBookingPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBookingPaymentResponse, error)

	// GetStationsWithResponse request
	GetStationsWithResponse(ctx context.Context, params *GetStationsParams, reqEditors ...RequestEditorFn) (*GetStationsResponse, error)

	// GetTripsWithResponse request
	GetTripsWithResponse(ctx context.Context, params *GetTripsParams, reqEditors ...RequestEditorFn) (*GetTripsResponse, error)
}

type GetBookingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *[]Booking `json:"data,omitempty"`
		Links *struct {
			Next *string `json:"next,omitempty"`
			Prev *string `json:"prev,omitempty"`
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`
	}
	XML200 *struct {
		Data  *[]Booking `json:"data,omitempty"`
		Links *struct {
			Next *string `json:"next,omitempty"`
			Prev *string `json:"prev,omitempty"`
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`
	}
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON429 *TooManyRequests
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBookingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBookingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBookingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// HasBicycle Indicates whether the passenger has a bicycle.
		HasBicycle *bool `json:"has_bicycle,omitempty"`

		// HasDog Indicates whether the passenger has a dog.
		HasDog *bool `json:"has_dog,omitempty"`

		// Id Unique identifier for the booking
		Id    *openapi_types.UUID `json:"id,omitempty"`
		Links *LinksSelf          `json:"links,omitempty"`

		// PassengerName Name of the passenger
		PassengerName *string `json:"passenger_name,omitempty"`

		// TripId Identifier of the booked trip
		TripId *openapi_types.UUID `json:"trip_id,omitempty"`
	}
	XML201 *struct {
		// HasBicycle Indicates whether the passenger has a bicycle.
		HasBicycle *bool `json:"has_bicycle,omitempty"`

		// HasDog Indicates whether the passenger has a dog.
		HasDog *bool `json:"has_dog,omitempty"`

		// Id Unique identifier for the booking
		Id    *openapi_types.UUID `json:"id,omitempty"`
		Links *LinksSelf          `json:"links,omitempty"`

		// PassengerName Name of the passenger
		PassengerName *string `json:"passenger_name,omitempty"`

		// TripId Identifier of the booked trip
		TripId *openapi_types.UUID `json:"trip_id,omitempty"`
	}
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON409 *Conflict
	ApplicationproblemJSON429 *TooManyRequests
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateBookingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBookingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBookingResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON429 *TooManyRequests
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteBookingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBookingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBookingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// HasBicycle Indicates whether the passenger has a bicycle.
		HasBicycle *bool `json:"has_bicycle,omitempty"`

		// HasDog Indicates whether the passenger has a dog.
		HasDog *bool `json:"has_dog,omitempty"`

		// Id Unique identifier for the booking
		Id    *openapi_types.UUID `json:"id,omitempty"`
		Links *LinksSelf          `json:"links,omitempty"`

		// PassengerName Name of the passenger
		PassengerName *string `json:"passenger_name,omitempty"`

		// TripId Identifier of the booked trip
		TripId *openapi_types.UUID `json:"trip_id,omitempty"`
	}
	XML200 *struct {
		// HasBicycle Indicates whether the passenger has a bicycle.
		HasBicycle *bool `json:"has_bicycle,omitempty"`

		// HasDog Indicates whether the passenger has a dog.
		HasDog *bool `json:"has_dog,omitempty"`

		// Id Unique identifier for the booking
		Id    *openapi_types.UUID `json:"id,omitempty"`
		Links *LinksSelf          `json:"links,omitempty"`

		// PassengerName Name of the passenger
		PassengerName *string `json:"passenger_name,omitempty"`

		// TripId Identifier of the booked trip
		TripId *openapi_types.UUID `json:"trip_id,omitempty"`
	}
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON429 *TooManyRequests
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBookingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBookingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBookingPaymentResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *BookingPayment
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON429 *TooManyRequests
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateBookingPaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBookingPaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *[]Station `json:"data,omitempty"`
		Links *struct {
			Next *string `json:"next,omitempty"`
			Prev *string `json:"prev,omitempty"`
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`
	}
	XML200 *struct {
		Data  *[]Station `json:"data,omitempty"`
		Links *struct {
			Next *string `json:"next,omitempty"`
			Prev *string `json:"prev,omitempty"`
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`
	}
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON429 *TooManyRequests
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTripsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			// ArrivalTime The date and time when the trip arrives
			ArrivalTime *time.Time `json:"arrival_time,omitempty"`

			// BicyclesAllowed Indicates whether bicycles are allowed on the trip
			BicyclesAllowed *bool `json:"bicycles_allowed,omitempty"`

			// DepartureTime The date and time when the trip departs
			DepartureTime *time.Time `json:"departure_time,omitempty"`

			// Destination The destination station of the trip
			Destination *string `json:"destination,omitempty"`

			// DogsAllowed Indicates whether dogs are allowed on the trip
			DogsAllowed *bool `json:"dogs_allowed,omitempty"`

			// Id Unique identifier for the trip
			Id *openapi_types.UUID `json:"id,omitempty"`

			// Operator The name of the operator of the trip
			Operator *string `json:"operator,omitempty"`

			// Origin The starting station of the trip
			Origin *string `json:"origin,omitempty"`

			// Price The cost of the trip
			Price *float32 `json:"price,omitempty"`
			Self  *string  `json:"self,omitempty"`
		} `json:"data,omitempty"`
		Links *struct {
			Next *string `json:"next,omitempty"`
			Prev *string `json:"prev,omitempty"`
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`
	}
	XML200 *struct {
		Data  *[]Trip `json:"data,omitempty"`
		Links *struct {
			Next *string `json:"next,omitempty"`
			Prev *string `json:"prev,omitempty"`
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`
	}
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON429 *TooManyRequests
	ApplicationproblemJSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTripsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTripsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBookingsWithResponse request returning *GetBookingsResponse
func (c *ClientWithResponses) GetBookingsWithResponse(ctx context.Context, params *GetBookingsParams, reqEditors ...RequestEditorFn) (*GetBookingsResponse, error) {
	rsp, err := c.GetBookings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookingsResponse(rsp)
}

// CreateBookingWithBodyWithResponse request with arbitrary body returning *CreateBookingResponse
func (c *ClientWithResponses) CreateBookingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBookingResponse, error) {
	rsp, err := c.CreateBookingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBookingResponse(rsp)
}

func (c *ClientWithResponses) CreateBookingWithResponse(ctx context.Context, body CreateBookingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBookingResponse, error) {
	rsp, err := c.CreateBooking(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBookingResponse(rsp)
}

// DeleteBookingWithResponse request returning *DeleteBookingResponse
func (c *ClientWithResponses) DeleteBookingWithResponse(ctx context.Context, bookingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteBookingResponse, error) {
	rsp, err := c.DeleteBooking(ctx, bookingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBookingResponse(rsp)
}

// GetBookingWithResponse request returning *GetBookingResponse
func (c *ClientWithResponses) GetBookingWithResponse(ctx context.Context, bookingId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetBookingResponse, error) {
	rsp, err := c.GetBooking(ctx, bookingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBookingResponse(rsp)
}

// CreateBookingPaymentWithBodyWithResponse request with arbitrary body returning *CreateBookingPaymentResponse
func (c *ClientWithResponses) CreateBookingPaymentWithBodyWithResponse(ctx context.Context, bookingId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBookingPaymentResponse, error) {
	rsp, err := c.CreateBookingPaymentWithBody(ctx, bookingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBookingPaymentResponse(rsp)
}

func (c *ClientWithResponses) CreateBookingPaymentWithResponse(ctx context.Context, bookingId openapi_types.UUID, body CreateBookingPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBookingPaymentResponse, error) {
	rsp, err := c.CreateBookingPayment(ctx, bookingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBookingPaymentResponse(rsp)
}

// GetStationsWithResponse request returning *GetStationsResponse
func (c *ClientWithResponses) GetStationsWithResponse(ctx context.Context, params *GetStationsParams, reqEditors ...RequestEditorFn) (*GetStationsResponse, error) {
	rsp, err := c.GetStations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStationsResponse(rsp)
}

// GetTripsWithResponse request returning *GetTripsResponse
func (c *ClientWithResponses) GetTripsWithResponse(ctx context.Context, params *GetTripsParams, reqEditors ...RequestEditorFn) (*GetTripsResponse, error) {
	rsp, err := c.GetTrips(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTripsResponse(rsp)
}

// ParseGetBookingsResponse parses an HTTP response from a GetBookingsWithResponse call
func ParseGetBookingsResponse(rsp *http.Response) (*GetBookingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBookingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *[]Booking `json:"data,omitempty"`
			Links *struct {
				Next *string `json:"next,omitempty"`
				Prev *string `json:"prev,omitempty"`
				Self *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest struct {
			Data  *[]Booking `json:"data,omitempty"`
			Links *struct {
				Next *string `json:"next,omitempty"`
				Prev *string `json:"prev,omitempty"`
				Self *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		}
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 403:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 429:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/problem+xml) unsupported

	}

	return response, nil
}

// ParseCreateBookingResponse parses an HTTP response from a CreateBookingWithResponse call
func ParseCreateBookingResponse(rsp *http.Response) (*CreateBookingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBookingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// HasBicycle Indicates whether the passenger has a bicycle.
			HasBicycle *bool `json:"has_bicycle,omitempty"`

			// HasDog Indicates whether the passenger has a dog.
			HasDog *bool `json:"has_dog,omitempty"`

			// Id Unique identifier for the booking
			Id    *openapi_types.UUID `json:"id,omitempty"`
			Links *LinksSelf          `json:"links,omitempty"`

			// PassengerName Name of the passenger
			PassengerName *string `json:"passenger_name,omitempty"`

			// TripId Identifier of the booked trip
			TripId *openapi_types.UUID `json:"trip_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 201:
		var dest struct {
			// HasBicycle Indicates whether the passenger has a bicycle.
			HasBicycle *bool `json:"has_bicycle,omitempty"`

			// HasDog Indicates whether the passenger has a dog.
			HasDog *bool `json:"has_dog,omitempty"`

			// Id Unique identifier for the booking
			Id    *openapi_types.UUID `json:"id,omitempty"`
			Links *LinksSelf          `json:"links,omitempty"`

			// PassengerName Name of the passenger
			PassengerName *string `json:"passenger_name,omitempty"`

			// TripId Identifier of the booked trip
			TripId *openapi_types.UUID `json:"trip_id,omitempty"`
		}
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML201 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 404:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 409:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 429:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/problem+xml) unsupported

	}

	return response, nil
}

// ParseDeleteBookingResponse parses an HTTP response from a DeleteBookingWithResponse call
func ParseDeleteBookingResponse(rsp *http.Response) (*DeleteBookingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBookingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 403:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 404:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 429:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/problem+xml) unsupported

	}

	return response, nil
}

// ParseGetBookingResponse parses an HTTP response from a GetBookingWithResponse call
func ParseGetBookingResponse(rsp *http.Response) (*GetBookingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBookingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// HasBicycle Indicates whether the passenger has a bicycle.
			HasBicycle *bool `json:"has_bicycle,omitempty"`

			// HasDog Indicates whether the passenger has a dog.
			HasDog *bool `json:"has_dog,omitempty"`

			// Id Unique identifier for the booking
			Id    *openapi_types.UUID `json:"id,omitempty"`
			Links *LinksSelf          `json:"links,omitempty"`

			// PassengerName Name of the passenger
			PassengerName *string `json:"passenger_name,omitempty"`

			// TripId Identifier of the booked trip
			TripId *openapi_types.UUID `json:"trip_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest struct {
			// HasBicycle Indicates whether the passenger has a bicycle.
			HasBicycle *bool `json:"has_bicycle,omitempty"`

			// HasDog Indicates whether the passenger has a dog.
			HasDog *bool `json:"has_dog,omitempty"`

			// Id Unique identifier for the booking
			Id    *openapi_types.UUID `json:"id,omitempty"`
			Links *LinksSelf          `json:"links,omitempty"`

			// PassengerName Name of the passenger
			PassengerName *string `json:"passenger_name,omitempty"`

			// TripId Identifier of the booked trip
			TripId *openapi_types.UUID `json:"trip_id,omitempty"`
		}
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 403:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 404:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 429:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/problem+xml) unsupported

	}

	return response, nil
}

// ParseCreateBookingPaymentResponse parses an HTTP response from a CreateBookingPaymentWithResponse call
func ParseCreateBookingPaymentResponse(rsp *http.Response) (*CreateBookingPaymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBookingPaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BookingPayment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 403:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 429:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/problem+xml) unsupported

	}

	return response, nil
}

// ParseGetStationsResponse parses an HTTP response from a GetStationsWithResponse call
func ParseGetStationsResponse(rsp *http.Response) (*GetStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *[]Station `json:"data,omitempty"`
			Links *struct {
				Next *string `json:"next,omitempty"`
				Prev *string `json:"prev,omitempty"`
				Self *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest struct {
			Data  *[]Station `json:"data,omitempty"`
			Links *struct {
				Next *string `json:"next,omitempty"`
				Prev *string `json:"prev,omitempty"`
				Self *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		}
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 403:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 429:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/problem+xml) unsupported

	}

	return response, nil
}

// ParseGetTripsResponse parses an HTTP response from a GetTripsWithResponse call
func ParseGetTripsResponse(rsp *http.Response) (*GetTripsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTripsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				// ArrivalTime The date and time when the trip arrives
				ArrivalTime *time.Time `json:"arrival_time,omitempty"`

				// BicyclesAllowed Indicates whether bicycles are allowed on the trip
				BicyclesAllowed *bool `json:"bicycles_allowed,omitempty"`

				// DepartureTime The date and time when the trip departs
				DepartureTime *time.Time `json:"departure_time,omitempty"`

				// Destination The destination station of the trip
				Destination *string `json:"destination,omitempty"`

				// DogsAllowed Indicates whether dogs are allowed on the trip
				DogsAllowed *bool `json:"dogs_allowed,omitempty"`

				// Id Unique identifier for the trip
				Id *openapi_types.UUID `json:"id,omitempty"`

				// Operator The name of the operator of the trip
				Operator *string `json:"operator,omitempty"`

				// Origin The starting station of the trip
				Origin *string `json:"origin,omitempty"`

				// Price The cost of the trip
				Price *float32 `json:"price,omitempty"`
				Self  *string  `json:"self,omitempty"`
			} `json:"data,omitempty"`
			Links *struct {
				Next *string `json:"next,omitempty"`
				Prev *string `json:"prev,omitempty"`
				Self *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest struct {
			Data  *[]Trip `json:"data,omitempty"`
			Links *struct {
				Next *string `json:"next,omitempty"`
				Prev *string `json:"prev,omitempty"`
				Self *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		}
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 403:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 429:
	// Content-type (application/problem+xml) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/problem+xml) unsupported

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List existing bookings
	// (GET /bookings)
	GetBookings(w http.ResponseWriter, r *http.Request, params GetBookingsParams)
	// Create a booking
	// (POST /bookings)
	CreateBooking(w http.ResponseWriter, r *http.Request)
	// Delete a booking
	// (DELETE /bookings/{bookingId})
	DeleteBooking(w http.ResponseWriter, r *http.Request, bookingId openapi_types.UUID)
	// Get a booking
	// (GET /bookings/{bookingId})
	GetBooking(w http.ResponseWriter, r *http.Request, bookingId openapi_types.UUID)
	// Pay for a Booking
	// (POST /bookings/{bookingId}/payment)
	CreateBookingPayment(w http.ResponseWriter, r *http.Request, bookingId openapi_types.UUID)
	// Get a list of train stations
	// (GET /stations)
	GetStations(w http.ResponseWriter, r *http.Request, params GetStationsParams)
	// Get available train trips
	// (GET /trips)
	GetTrips(w http.ResponseWriter, r *http.Request, params GetTripsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetBookings operation middleware
func (siw *ServerInterfaceWrapper) GetBookings(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"read"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBookingsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBookings(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateBooking operation middleware
func (siw *ServerInterfaceWrapper) CreateBooking(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"write"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBooking(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteBooking operation middleware
func (siw *ServerInterfaceWrapper) DeleteBooking(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bookingId" -------------
	var bookingId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "bookingId", r.PathValue("bookingId"), &bookingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bookingId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"write"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBooking(w, r, bookingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetBooking operation middleware
func (siw *ServerInterfaceWrapper) GetBooking(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bookingId" -------------
	var bookingId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "bookingId", r.PathValue("bookingId"), &bookingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bookingId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"read"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBooking(w, r, bookingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateBookingPayment operation middleware
func (siw *ServerInterfaceWrapper) CreateBookingPayment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "bookingId" -------------
	var bookingId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "bookingId", r.PathValue("bookingId"), &bookingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bookingId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"read"})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBookingPayment(w, r, bookingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetStations operation middleware
func (siw *ServerInterfaceWrapper) GetStations(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"read"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStationsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "coordinates" -------------

	err = runtime.BindQueryParameter("form", true, false, "coordinates", r.URL.Query(), &params.Coordinates)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "coordinates", Err: err})
		return
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "country" -------------

	err = runtime.BindQueryParameter("form", true, false, "country", r.URL.Query(), &params.Country)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "country", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStations(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTrips operation middleware
func (siw *ServerInterfaceWrapper) GetTrips(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2Scopes, []string{"read"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTripsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Required query parameter "origin" -------------

	if paramValue := r.URL.Query().Get("origin"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "origin"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "origin", r.URL.Query(), &params.Origin)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "origin", Err: err})
		return
	}

	// ------------- Required query parameter "destination" -------------

	if paramValue := r.URL.Query().Get("destination"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "destination"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "destination", r.URL.Query(), &params.Destination)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "destination", Err: err})
		return
	}

	// ------------- Required query parameter "date" -------------

	if paramValue := r.URL.Query().Get("date"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "date"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "bicycles" -------------

	err = runtime.BindQueryParameter("form", true, false, "bicycles", r.URL.Query(), &params.Bicycles)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bicycles", Err: err})
		return
	}

	// ------------- Optional query parameter "dogs" -------------

	err = runtime.BindQueryParameter("form", true, false, "dogs", r.URL.Query(), &params.Dogs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "dogs", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTrips(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/bookings", wrapper.GetBookings)
	m.HandleFunc("POST "+options.BaseURL+"/bookings", wrapper.CreateBooking)
	m.HandleFunc("DELETE "+options.BaseURL+"/bookings/{bookingId}", wrapper.DeleteBooking)
	m.HandleFunc("GET "+options.BaseURL+"/bookings/{bookingId}", wrapper.GetBooking)
	m.HandleFunc("POST "+options.BaseURL+"/bookings/{bookingId}/payment", wrapper.CreateBookingPayment)
	m.HandleFunc("GET "+options.BaseURL+"/stations", wrapper.GetStations)
	m.HandleFunc("GET "+options.BaseURL+"/trips", wrapper.GetTrips)

	return m
}

type BadRequestResponseHeaders struct {
	RateLimit string
}
type BadRequestApplicationProblemPlusJSONResponse struct {
	Body Problem

	Headers BadRequestResponseHeaders
}
type BadRequestApplicationproblemXmlResponse struct {
	Body io.Reader

	Headers       BadRequestResponseHeaders
	ContentLength int64
}

type ConflictResponseHeaders struct {
	RateLimit string
}
type ConflictApplicationProblemPlusJSONResponse struct {
	Body Problem

	Headers ConflictResponseHeaders
}
type ConflictApplicationproblemXmlResponse struct {
	Body io.Reader

	Headers       ConflictResponseHeaders
	ContentLength int64
}

type ForbiddenResponseHeaders struct {
	RateLimit string
}
type ForbiddenApplicationProblemPlusJSONResponse struct {
	Body Problem

	Headers ForbiddenResponseHeaders
}
type ForbiddenApplicationproblemXmlResponse struct {
	Body io.Reader

	Headers       ForbiddenResponseHeaders
	ContentLength int64
}

type InternalServerErrorResponseHeaders struct {
	RateLimit string
}
type InternalServerErrorApplicationProblemPlusJSONResponse struct {
	Body Problem

	Headers InternalServerErrorResponseHeaders
}
type InternalServerErrorApplicationproblemXmlResponse struct {
	Body io.Reader

	Headers       InternalServerErrorResponseHeaders
	ContentLength int64
}

type NotFoundResponseHeaders struct {
	RateLimit string
}
type NotFoundApplicationProblemPlusJSONResponse struct {
	Body Problem

	Headers NotFoundResponseHeaders
}
type NotFoundApplicationproblemXmlResponse struct {
	Body io.Reader

	Headers       NotFoundResponseHeaders
	ContentLength int64
}

type TooManyRequestsResponseHeaders struct {
	RateLimit  string
	RetryAfter string
}
type TooManyRequestsApplicationProblemPlusJSONResponse struct {
	Body Problem

	Headers TooManyRequestsResponseHeaders
}
type TooManyRequestsApplicationproblemXmlResponse struct {
	Body io.Reader

	Headers       TooManyRequestsResponseHeaders
	ContentLength int64
}

type UnauthorizedResponseHeaders struct {
	RateLimit string
}
type UnauthorizedApplicationProblemPlusJSONResponse struct {
	Body Problem

	Headers UnauthorizedResponseHeaders
}
type UnauthorizedApplicationproblemXmlResponse struct {
	Body io.Reader

	Headers       UnauthorizedResponseHeaders
	ContentLength int64
}

type GetBookingsRequestObject struct {
	Params GetBookingsParams
}

type GetBookingsResponseObject interface {
	VisitGetBookingsResponse(w http.ResponseWriter) error
}

type GetBookings200ResponseHeaders struct {
	CacheControl string
	RateLimit    string
}

type GetBookings200JSONResponse struct {
	Body struct {
		Data  *[]Booking `json:"data,omitempty"`
		Links *struct {
			Next *string `json:"next,omitempty"`
			Prev *string `json:"prev,omitempty"`
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`
	}
	Headers GetBookings200ResponseHeaders
}

func (response GetBookings200JSONResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBookings200ApplicationxmlResponse struct {
	Body          io.Reader
	Headers       GetBookings200ResponseHeaders
	ContentLength int64
}

func (response GetBookings200ApplicationxmlResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBookings400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response GetBookings400ApplicationProblemPlusJSONResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBookings400ApplicationproblemXmlResponse struct {
	BadRequestApplicationproblemXmlResponse
}

func (response GetBookings400ApplicationproblemXmlResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBookings401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetBookings401ApplicationProblemPlusJSONResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBookings401ApplicationproblemXmlResponse struct {
	UnauthorizedApplicationproblemXmlResponse
}

func (response GetBookings401ApplicationproblemXmlResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBookings403ApplicationProblemPlusJSONResponse struct {
	ForbiddenApplicationProblemPlusJSONResponse
}

func (response GetBookings403ApplicationProblemPlusJSONResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBookings403ApplicationproblemXmlResponse struct {
	ForbiddenApplicationproblemXmlResponse
}

func (response GetBookings403ApplicationproblemXmlResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBookings429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response GetBookings429ApplicationProblemPlusJSONResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBookings429ApplicationproblemXmlResponse struct {
	TooManyRequestsApplicationproblemXmlResponse
}

func (response GetBookings429ApplicationproblemXmlResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBookings500ApplicationProblemPlusJSONResponse struct {
	InternalServerErrorApplicationProblemPlusJSONResponse
}

func (response GetBookings500ApplicationProblemPlusJSONResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBookings500ApplicationproblemXmlResponse struct {
	InternalServerErrorApplicationproblemXmlResponse
}

func (response GetBookings500ApplicationproblemXmlResponse) VisitGetBookingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBookingRequestObject struct {
	JSONBody *CreateBookingJSONRequestBody
	Body     io.Reader
}

type CreateBookingResponseObject interface {
	VisitCreateBookingResponse(w http.ResponseWriter) error
}

type CreateBooking201JSONResponse struct {
	// HasBicycle Indicates whether the passenger has a bicycle.
	HasBicycle *bool `json:"has_bicycle,omitempty"`

	// HasDog Indicates whether the passenger has a dog.
	HasDog *bool `json:"has_dog,omitempty"`

	// Id Unique identifier for the booking
	Id    *openapi_types.UUID `json:"id,omitempty"`
	Links *LinksSelf          `json:"links,omitempty"`

	// PassengerName Name of the passenger
	PassengerName *string `json:"passenger_name,omitempty"`

	// TripId Identifier of the booked trip
	TripId *openapi_types.UUID `json:"trip_id,omitempty"`
}

func (response CreateBooking201JSONResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateBooking201ApplicationxmlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response CreateBooking201ApplicationxmlResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(201)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBooking400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response CreateBooking400ApplicationProblemPlusJSONResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBooking400ApplicationproblemXmlResponse struct {
	BadRequestApplicationproblemXmlResponse
}

func (response CreateBooking400ApplicationproblemXmlResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBooking401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CreateBooking401ApplicationProblemPlusJSONResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBooking401ApplicationproblemXmlResponse struct {
	UnauthorizedApplicationproblemXmlResponse
}

func (response CreateBooking401ApplicationproblemXmlResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBooking404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response CreateBooking404ApplicationProblemPlusJSONResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBooking404ApplicationproblemXmlResponse struct {
	NotFoundApplicationproblemXmlResponse
}

func (response CreateBooking404ApplicationproblemXmlResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(404)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBooking409ApplicationProblemPlusJSONResponse struct {
	ConflictApplicationProblemPlusJSONResponse
}

func (response CreateBooking409ApplicationProblemPlusJSONResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBooking409ApplicationproblemXmlResponse struct {
	ConflictApplicationproblemXmlResponse
}

func (response CreateBooking409ApplicationproblemXmlResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(409)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBooking429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response CreateBooking429ApplicationProblemPlusJSONResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBooking429ApplicationproblemXmlResponse struct {
	TooManyRequestsApplicationproblemXmlResponse
}

func (response CreateBooking429ApplicationproblemXmlResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBooking500ApplicationProblemPlusJSONResponse struct {
	InternalServerErrorApplicationProblemPlusJSONResponse
}

func (response CreateBooking500ApplicationProblemPlusJSONResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBooking500ApplicationproblemXmlResponse struct {
	InternalServerErrorApplicationproblemXmlResponse
}

func (response CreateBooking500ApplicationproblemXmlResponse) VisitCreateBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteBookingRequestObject struct {
	BookingId openapi_types.UUID `json:"bookingId"`
}

type DeleteBookingResponseObject interface {
	VisitDeleteBookingResponse(w http.ResponseWriter) error
}

type DeleteBooking204Response struct {
}

func (response DeleteBooking204Response) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteBooking400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response DeleteBooking400ApplicationProblemPlusJSONResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteBooking400ApplicationproblemXmlResponse struct {
	BadRequestApplicationproblemXmlResponse
}

func (response DeleteBooking400ApplicationproblemXmlResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteBooking401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response DeleteBooking401ApplicationProblemPlusJSONResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteBooking401ApplicationproblemXmlResponse struct {
	UnauthorizedApplicationproblemXmlResponse
}

func (response DeleteBooking401ApplicationproblemXmlResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteBooking403ApplicationProblemPlusJSONResponse struct {
	ForbiddenApplicationProblemPlusJSONResponse
}

func (response DeleteBooking403ApplicationProblemPlusJSONResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteBooking403ApplicationproblemXmlResponse struct {
	ForbiddenApplicationproblemXmlResponse
}

func (response DeleteBooking403ApplicationproblemXmlResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteBooking404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response DeleteBooking404ApplicationProblemPlusJSONResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteBooking404ApplicationproblemXmlResponse struct {
	NotFoundApplicationproblemXmlResponse
}

func (response DeleteBooking404ApplicationproblemXmlResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(404)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteBooking429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response DeleteBooking429ApplicationProblemPlusJSONResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteBooking429ApplicationproblemXmlResponse struct {
	TooManyRequestsApplicationproblemXmlResponse
}

func (response DeleteBooking429ApplicationproblemXmlResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteBooking500ApplicationProblemPlusJSONResponse struct {
	InternalServerErrorApplicationProblemPlusJSONResponse
}

func (response DeleteBooking500ApplicationProblemPlusJSONResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteBooking500ApplicationproblemXmlResponse struct {
	InternalServerErrorApplicationproblemXmlResponse
}

func (response DeleteBooking500ApplicationproblemXmlResponse) VisitDeleteBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBookingRequestObject struct {
	BookingId openapi_types.UUID `json:"bookingId"`
}

type GetBookingResponseObject interface {
	VisitGetBookingResponse(w http.ResponseWriter) error
}

type GetBooking200ResponseHeaders struct {
	CacheControl string
	RateLimit    string
}

type GetBooking200JSONResponse struct {
	Body struct {
		// HasBicycle Indicates whether the passenger has a bicycle.
		HasBicycle *bool `json:"has_bicycle,omitempty"`

		// HasDog Indicates whether the passenger has a dog.
		HasDog *bool `json:"has_dog,omitempty"`

		// Id Unique identifier for the booking
		Id    *openapi_types.UUID `json:"id,omitempty"`
		Links *LinksSelf          `json:"links,omitempty"`

		// PassengerName Name of the passenger
		PassengerName *string `json:"passenger_name,omitempty"`

		// TripId Identifier of the booked trip
		TripId *openapi_types.UUID `json:"trip_id,omitempty"`
	}
	Headers GetBooking200ResponseHeaders
}

func (response GetBooking200JSONResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBooking200ApplicationxmlResponse struct {
	Body          io.Reader
	Headers       GetBooking200ResponseHeaders
	ContentLength int64
}

func (response GetBooking200ApplicationxmlResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBooking400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response GetBooking400ApplicationProblemPlusJSONResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBooking400ApplicationproblemXmlResponse struct {
	BadRequestApplicationproblemXmlResponse
}

func (response GetBooking400ApplicationproblemXmlResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBooking401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetBooking401ApplicationProblemPlusJSONResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBooking401ApplicationproblemXmlResponse struct {
	UnauthorizedApplicationproblemXmlResponse
}

func (response GetBooking401ApplicationproblemXmlResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBooking403ApplicationProblemPlusJSONResponse struct {
	ForbiddenApplicationProblemPlusJSONResponse
}

func (response GetBooking403ApplicationProblemPlusJSONResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBooking403ApplicationproblemXmlResponse struct {
	ForbiddenApplicationproblemXmlResponse
}

func (response GetBooking403ApplicationproblemXmlResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBooking404ApplicationProblemPlusJSONResponse struct {
	NotFoundApplicationProblemPlusJSONResponse
}

func (response GetBooking404ApplicationProblemPlusJSONResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBooking404ApplicationproblemXmlResponse struct {
	NotFoundApplicationproblemXmlResponse
}

func (response GetBooking404ApplicationproblemXmlResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(404)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBooking429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response GetBooking429ApplicationProblemPlusJSONResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBooking429ApplicationproblemXmlResponse struct {
	TooManyRequestsApplicationproblemXmlResponse
}

func (response GetBooking429ApplicationproblemXmlResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetBooking500ApplicationProblemPlusJSONResponse struct {
	InternalServerErrorApplicationProblemPlusJSONResponse
}

func (response GetBooking500ApplicationProblemPlusJSONResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetBooking500ApplicationproblemXmlResponse struct {
	InternalServerErrorApplicationproblemXmlResponse
}

func (response GetBooking500ApplicationproblemXmlResponse) VisitGetBookingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBookingPaymentRequestObject struct {
	BookingId openapi_types.UUID `json:"bookingId"`
	Body      *CreateBookingPaymentJSONRequestBody
}

type CreateBookingPaymentResponseObject interface {
	VisitCreateBookingPaymentResponse(w http.ResponseWriter) error
}

type CreateBookingPayment200ResponseHeaders struct {
	CacheControl string
	RateLimit    string
}

type CreateBookingPayment200JSONResponse struct {
	Body    BookingPayment
	Headers CreateBookingPayment200ResponseHeaders
}

func (response CreateBookingPayment200JSONResponse) VisitCreateBookingPaymentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBookingPayment400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response CreateBookingPayment400ApplicationProblemPlusJSONResponse) VisitCreateBookingPaymentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBookingPayment400ApplicationproblemXmlResponse struct {
	BadRequestApplicationproblemXmlResponse
}

func (response CreateBookingPayment400ApplicationproblemXmlResponse) VisitCreateBookingPaymentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBookingPayment401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response CreateBookingPayment401ApplicationProblemPlusJSONResponse) VisitCreateBookingPaymentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBookingPayment401ApplicationproblemXmlResponse struct {
	UnauthorizedApplicationproblemXmlResponse
}

func (response CreateBookingPayment401ApplicationproblemXmlResponse) VisitCreateBookingPaymentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBookingPayment403ApplicationProblemPlusJSONResponse struct {
	ForbiddenApplicationProblemPlusJSONResponse
}

func (response CreateBookingPayment403ApplicationProblemPlusJSONResponse) VisitCreateBookingPaymentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBookingPayment403ApplicationproblemXmlResponse struct {
	ForbiddenApplicationproblemXmlResponse
}

func (response CreateBookingPayment403ApplicationproblemXmlResponse) VisitCreateBookingPaymentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBookingPayment429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response CreateBookingPayment429ApplicationProblemPlusJSONResponse) VisitCreateBookingPaymentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBookingPayment429ApplicationproblemXmlResponse struct {
	TooManyRequestsApplicationproblemXmlResponse
}

func (response CreateBookingPayment429ApplicationproblemXmlResponse) VisitCreateBookingPaymentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type CreateBookingPayment500ApplicationProblemPlusJSONResponse struct {
	InternalServerErrorApplicationProblemPlusJSONResponse
}

func (response CreateBookingPayment500ApplicationProblemPlusJSONResponse) VisitCreateBookingPaymentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateBookingPayment500ApplicationproblemXmlResponse struct {
	InternalServerErrorApplicationproblemXmlResponse
}

func (response CreateBookingPayment500ApplicationproblemXmlResponse) VisitCreateBookingPaymentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetStationsRequestObject struct {
	Params GetStationsParams
}

type GetStationsResponseObject interface {
	VisitGetStationsResponse(w http.ResponseWriter) error
}

type GetStations200ResponseHeaders struct {
	CacheControl string
	RateLimit    string
}

type GetStations200JSONResponse struct {
	Body struct {
		Data  *[]Station `json:"data,omitempty"`
		Links *struct {
			Next *string `json:"next,omitempty"`
			Prev *string `json:"prev,omitempty"`
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`
	}
	Headers GetStations200ResponseHeaders
}

func (response GetStations200JSONResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetStations200ApplicationxmlResponse struct {
	Body          io.Reader
	Headers       GetStations200ResponseHeaders
	ContentLength int64
}

func (response GetStations200ApplicationxmlResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetStations400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response GetStations400ApplicationProblemPlusJSONResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetStations400ApplicationproblemXmlResponse struct {
	BadRequestApplicationproblemXmlResponse
}

func (response GetStations400ApplicationproblemXmlResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetStations401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetStations401ApplicationProblemPlusJSONResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetStations401ApplicationproblemXmlResponse struct {
	UnauthorizedApplicationproblemXmlResponse
}

func (response GetStations401ApplicationproblemXmlResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetStations403ApplicationProblemPlusJSONResponse struct {
	ForbiddenApplicationProblemPlusJSONResponse
}

func (response GetStations403ApplicationProblemPlusJSONResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetStations403ApplicationproblemXmlResponse struct {
	ForbiddenApplicationproblemXmlResponse
}

func (response GetStations403ApplicationproblemXmlResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetStations429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response GetStations429ApplicationProblemPlusJSONResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetStations429ApplicationproblemXmlResponse struct {
	TooManyRequestsApplicationproblemXmlResponse
}

func (response GetStations429ApplicationproblemXmlResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetStations500ApplicationProblemPlusJSONResponse struct {
	InternalServerErrorApplicationProblemPlusJSONResponse
}

func (response GetStations500ApplicationProblemPlusJSONResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetStations500ApplicationproblemXmlResponse struct {
	InternalServerErrorApplicationproblemXmlResponse
}

func (response GetStations500ApplicationproblemXmlResponse) VisitGetStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetTripsRequestObject struct {
	Params GetTripsParams
}

type GetTripsResponseObject interface {
	VisitGetTripsResponse(w http.ResponseWriter) error
}

type GetTrips200ResponseHeaders struct {
	CacheControl string
	RateLimit    string
}

type GetTrips200JSONResponse struct {
	Body struct {
		Data *[]struct {
			// ArrivalTime The date and time when the trip arrives
			ArrivalTime *time.Time `json:"arrival_time,omitempty"`

			// BicyclesAllowed Indicates whether bicycles are allowed on the trip
			BicyclesAllowed *bool `json:"bicycles_allowed,omitempty"`

			// DepartureTime The date and time when the trip departs
			DepartureTime *time.Time `json:"departure_time,omitempty"`

			// Destination The destination station of the trip
			Destination *string `json:"destination,omitempty"`

			// DogsAllowed Indicates whether dogs are allowed on the trip
			DogsAllowed *bool `json:"dogs_allowed,omitempty"`

			// Id Unique identifier for the trip
			Id *openapi_types.UUID `json:"id,omitempty"`

			// Operator The name of the operator of the trip
			Operator *string `json:"operator,omitempty"`

			// Origin The starting station of the trip
			Origin *string `json:"origin,omitempty"`

			// Price The cost of the trip
			Price *float32 `json:"price,omitempty"`
			Self  *string  `json:"self,omitempty"`
		} `json:"data,omitempty"`
		Links *struct {
			Next *string `json:"next,omitempty"`
			Prev *string `json:"prev,omitempty"`
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`
	}
	Headers GetTrips200ResponseHeaders
}

func (response GetTrips200JSONResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetTrips200ApplicationxmlResponse struct {
	Body          io.Reader
	Headers       GetTrips200ResponseHeaders
	ContentLength int64
}

func (response GetTrips200ApplicationxmlResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetTrips400ApplicationProblemPlusJSONResponse struct {
	BadRequestApplicationProblemPlusJSONResponse
}

func (response GetTrips400ApplicationProblemPlusJSONResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetTrips400ApplicationproblemXmlResponse struct {
	BadRequestApplicationproblemXmlResponse
}

func (response GetTrips400ApplicationproblemXmlResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(400)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetTrips401ApplicationProblemPlusJSONResponse struct {
	UnauthorizedApplicationProblemPlusJSONResponse
}

func (response GetTrips401ApplicationProblemPlusJSONResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetTrips401ApplicationproblemXmlResponse struct {
	UnauthorizedApplicationproblemXmlResponse
}

func (response GetTrips401ApplicationproblemXmlResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(401)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetTrips403ApplicationProblemPlusJSONResponse struct {
	ForbiddenApplicationProblemPlusJSONResponse
}

func (response GetTrips403ApplicationProblemPlusJSONResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetTrips403ApplicationproblemXmlResponse struct {
	ForbiddenApplicationproblemXmlResponse
}

func (response GetTrips403ApplicationproblemXmlResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(403)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetTrips429ApplicationProblemPlusJSONResponse struct {
	TooManyRequestsApplicationProblemPlusJSONResponse
}

func (response GetTrips429ApplicationProblemPlusJSONResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetTrips429ApplicationproblemXmlResponse struct {
	TooManyRequestsApplicationproblemXmlResponse
}

func (response GetTrips429ApplicationproblemXmlResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(429)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetTrips500ApplicationProblemPlusJSONResponse struct {
	InternalServerErrorApplicationProblemPlusJSONResponse
}

func (response GetTrips500ApplicationProblemPlusJSONResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetTrips500ApplicationproblemXmlResponse struct {
	InternalServerErrorApplicationproblemXmlResponse
}

func (response GetTrips500ApplicationproblemXmlResponse) VisitGetTripsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("RateLimit", fmt.Sprint(response.Headers.RateLimit))
	w.WriteHeader(500)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// List existing bookings
	// (GET /bookings)
	GetBookings(ctx context.Context, request GetBookingsRequestObject) (GetBookingsResponseObject, error)
	// Create a booking
	// (POST /bookings)
	CreateBooking(ctx context.Context, request CreateBookingRequestObject) (CreateBookingResponseObject, error)
	// Delete a booking
	// (DELETE /bookings/{bookingId})
	DeleteBooking(ctx context.Context, request DeleteBookingRequestObject) (DeleteBookingResponseObject, error)
	// Get a booking
	// (GET /bookings/{bookingId})
	GetBooking(ctx context.Context, request GetBookingRequestObject) (GetBookingResponseObject, error)
	// Pay for a Booking
	// (POST /bookings/{bookingId}/payment)
	CreateBookingPayment(ctx context.Context, request CreateBookingPaymentRequestObject) (CreateBookingPaymentResponseObject, error)
	// Get a list of train stations
	// (GET /stations)
	GetStations(ctx context.Context, request GetStationsRequestObject) (GetStationsResponseObject, error)
	// Get available train trips
	// (GET /trips)
	GetTrips(ctx context.Context, request GetTripsRequestObject) (GetTripsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// GetBookings operation middleware
func (sh *strictHandler) GetBookings(w http.ResponseWriter, r *http.Request, params GetBookingsParams) {
	var request GetBookingsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetBookings(ctx, request.(GetBookingsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetBookings")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetBookingsResponseObject); ok {
		if err := validResponse.VisitGetBookingsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateBooking operation middleware
func (sh *strictHandler) CreateBooking(w http.ResponseWriter, r *http.Request) {
	var request CreateBookingRequestObject

	if strings.HasPrefix(r.Header.Get("Content-Type"), "application/json") {

		var body CreateBookingJSONRequestBody
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
			return
		}
		request.JSONBody = &body
	}
	if strings.HasPrefix(r.Header.Get("Content-Type"), "application/xml") {
		request.Body = r.Body
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateBooking(ctx, request.(CreateBookingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateBooking")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateBookingResponseObject); ok {
		if err := validResponse.VisitCreateBookingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteBooking operation middleware
func (sh *strictHandler) DeleteBooking(w http.ResponseWriter, r *http.Request, bookingId openapi_types.UUID) {
	var request DeleteBookingRequestObject

	request.BookingId = bookingId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteBooking(ctx, request.(DeleteBookingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteBooking")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteBookingResponseObject); ok {
		if err := validResponse.VisitDeleteBookingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetBooking operation middleware
func (sh *strictHandler) GetBooking(w http.ResponseWriter, r *http.Request, bookingId openapi_types.UUID) {
	var request GetBookingRequestObject

	request.BookingId = bookingId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetBooking(ctx, request.(GetBookingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetBooking")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetBookingResponseObject); ok {
		if err := validResponse.VisitGetBookingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateBookingPayment operation middleware
func (sh *strictHandler) CreateBookingPayment(w http.ResponseWriter, r *http.Request, bookingId openapi_types.UUID) {
	var request CreateBookingPaymentRequestObject

	request.BookingId = bookingId

	var body CreateBookingPaymentJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateBookingPayment(ctx, request.(CreateBookingPaymentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateBookingPayment")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateBookingPaymentResponseObject); ok {
		if err := validResponse.VisitCreateBookingPaymentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetStations operation middleware
func (sh *strictHandler) GetStations(w http.ResponseWriter, r *http.Request, params GetStationsParams) {
	var request GetStationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetStations(ctx, request.(GetStationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetStations")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetStationsResponseObject); ok {
		if err := validResponse.VisitGetStationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetTrips operation middleware
func (sh *strictHandler) GetTrips(w http.ResponseWriter, r *http.Request, params GetTripsParams) {
	var request GetTripsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetTrips(ctx, request.(GetTripsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTrips")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetTripsResponseObject); ok {
		if err := validResponse.VisitGetTripsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}
