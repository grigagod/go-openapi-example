// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"context"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

type requestConfig struct {
	Client       ht.Client
	ServerURL    *url.URL
	EditRequest  func(req *http.Request) error
	EditResponse func(resp *http.Response) error
}

func (cfg *requestConfig) setDefaults(c baseClient) {
	if cfg.Client == nil {
		cfg.Client = c.cfg.Client
	}
}

func (cfg *requestConfig) onRequest(req *http.Request) error {
	if fn := cfg.EditRequest; fn != nil {
		return fn(req)
	}
	return nil
}

func (cfg *requestConfig) onResponse(resp *http.Response) error {
	if fn := cfg.EditResponse; fn != nil {
		return fn(resp)
	}
	return nil
}

// RequestOption defines options for request.
type RequestOption func(cfg *requestConfig)

// WithRequestClient sets client for request.
func WithRequestClient(client ht.Client) RequestOption {
	return func(cfg *requestConfig) {
		cfg.Client = client
	}
}

// WithEditRequest sets function to edit request.
func WithEditRequest(fn func(req *http.Request) error) RequestOption {
	return func(cfg *requestConfig) {
		cfg.EditRequest = fn
	}
}

// WithEditResponse sets function to edit response.
func WithEditResponse(fn func(resp *http.Response) error) RequestOption {
	return func(cfg *requestConfig) {
		cfg.EditResponse = fn
	}
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CreateBooking invokes create-booking operation.
	//
	// A booking is a temporary hold on a trip. It is not confirmed until the payment is processed.
	//
	// POST /bookings
	CreateBooking(ctx context.Context, request *Booking, options ...RequestOption) (CreateBookingRes, error)
	// CreateBookingPayment invokes create-booking-payment operation.
	//
	// A payment is an attempt to pay for the booking, which will confirm the booking for the user and
	// enable them to get their tickets.
	//
	// POST /bookings/{bookingId}/payment
	CreateBookingPayment(ctx context.Context, request *BookingPayment, params CreateBookingPaymentParams, options ...RequestOption) (CreateBookingPaymentRes, error)
	// DeleteBooking invokes delete-booking operation.
	//
	// Deletes a booking, cancelling the hold on the trip.
	//
	// DELETE /bookings/{bookingId}
	DeleteBooking(ctx context.Context, params DeleteBookingParams, options ...RequestOption) (DeleteBookingRes, error)
	// GetBooking invokes get-booking operation.
	//
	// Returns the details of a specific booking.
	//
	// GET /bookings/{bookingId}
	GetBooking(ctx context.Context, params GetBookingParams, options ...RequestOption) (GetBookingRes, error)
	// GetBookings invokes get-bookings operation.
	//
	// Returns a list of all trip bookings by the authenticated user.
	//
	// GET /bookings
	GetBookings(ctx context.Context, params GetBookingsParams, options ...RequestOption) (GetBookingsRes, error)
	// GetStations invokes get-stations operation.
	//
	// Returns a paginated and searchable list of all train stations.
	//
	// GET /stations
	GetStations(ctx context.Context, params GetStationsParams, options ...RequestOption) (GetStationsRes, error)
	// GetTrips invokes get-trips operation.
	//
	// Returns a list of available train trips between the specified origin and destination stations on
	// the given date, and allows for filtering by bicycle and dog allowances.
	//
	// GET /trips
	GetTrips(ctx context.Context, params GetTripsParams, options ...RequestOption) (GetTripsRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

// CreateBooking invokes create-booking operation.
//
// A booking is a temporary hold on a trip. It is not confirmed until the payment is processed.
//
// POST /bookings
func (c *Client) CreateBooking(ctx context.Context, request *Booking, options ...RequestOption) (CreateBookingRes, error) {
	res, err := c.sendCreateBooking(ctx, request)
	return res, err
}

func (c *Client) sendCreateBooking(ctx context.Context, request *Booking, requestOptions ...RequestOption) (res CreateBookingRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create-booking"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/bookings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateBookingOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/bookings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateBookingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2"
			switch err := c.securityOAuth2(ctx, CreateBookingOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeCreateBookingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateBookingPayment invokes create-booking-payment operation.
//
// A payment is an attempt to pay for the booking, which will confirm the booking for the user and
// enable them to get their tickets.
//
// POST /bookings/{bookingId}/payment
func (c *Client) CreateBookingPayment(ctx context.Context, request *BookingPayment, params CreateBookingPaymentParams, options ...RequestOption) (CreateBookingPaymentRes, error) {
	res, err := c.sendCreateBookingPayment(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateBookingPayment(ctx context.Context, request *BookingPayment, params CreateBookingPaymentParams, requestOptions ...RequestOption) (res CreateBookingPaymentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create-booking-payment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/bookings/{bookingId}/payment"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateBookingPaymentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/bookings/"
	{
		// Encode "bookingId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bookingId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BookingId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/payment"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateBookingPaymentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2"
			switch err := c.securityOAuth2(ctx, CreateBookingPaymentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeCreateBookingPaymentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteBooking invokes delete-booking operation.
//
// Deletes a booking, cancelling the hold on the trip.
//
// DELETE /bookings/{bookingId}
func (c *Client) DeleteBooking(ctx context.Context, params DeleteBookingParams, options ...RequestOption) (DeleteBookingRes, error) {
	res, err := c.sendDeleteBooking(ctx, params)
	return res, err
}

func (c *Client) sendDeleteBooking(ctx context.Context, params DeleteBookingParams, requestOptions ...RequestOption) (res DeleteBookingRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete-booking"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/bookings/{bookingId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteBookingOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/bookings/"
	{
		// Encode "bookingId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bookingId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BookingId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2"
			switch err := c.securityOAuth2(ctx, DeleteBookingOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeDeleteBookingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBooking invokes get-booking operation.
//
// Returns the details of a specific booking.
//
// GET /bookings/{bookingId}
func (c *Client) GetBooking(ctx context.Context, params GetBookingParams, options ...RequestOption) (GetBookingRes, error) {
	res, err := c.sendGetBooking(ctx, params)
	return res, err
}

func (c *Client) sendGetBooking(ctx context.Context, params GetBookingParams, requestOptions ...RequestOption) (res GetBookingRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-booking"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/bookings/{bookingId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetBookingOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/bookings/"
	{
		// Encode "bookingId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bookingId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BookingId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2"
			switch err := c.securityOAuth2(ctx, GetBookingOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeGetBookingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBookings invokes get-bookings operation.
//
// Returns a list of all trip bookings by the authenticated user.
//
// GET /bookings
func (c *Client) GetBookings(ctx context.Context, params GetBookingsParams, options ...RequestOption) (GetBookingsRes, error) {
	res, err := c.sendGetBookings(ctx, params)
	return res, err
}

func (c *Client) sendGetBookings(ctx context.Context, params GetBookingsParams, requestOptions ...RequestOption) (res GetBookingsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-bookings"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/bookings"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetBookingsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/bookings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2"
			switch err := c.securityOAuth2(ctx, GetBookingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeGetBookingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStations invokes get-stations operation.
//
// Returns a paginated and searchable list of all train stations.
//
// GET /stations
func (c *Client) GetStations(ctx context.Context, params GetStationsParams, options ...RequestOption) (GetStationsRes, error) {
	res, err := c.sendGetStations(ctx, params)
	return res, err
}

func (c *Client) sendGetStations(ctx context.Context, params GetStationsParams, requestOptions ...RequestOption) (res GetStationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-stations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/stations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetStationsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/stations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "coordinates" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "coordinates",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Coordinates.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "search" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Search.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "country" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "country",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Country.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2"
			switch err := c.securityOAuth2(ctx, GetStationsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeGetStationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTrips invokes get-trips operation.
//
// Returns a list of available train trips between the specified origin and destination stations on
// the given date, and allows for filtering by bicycle and dog allowances.
//
// GET /trips
func (c *Client) GetTrips(ctx context.Context, params GetTripsParams, options ...RequestOption) (GetTripsRes, error) {
	res, err := c.sendGetTrips(ctx, params)
	return res, err
}

func (c *Client) sendGetTrips(ctx context.Context, params GetTripsParams, requestOptions ...RequestOption) (res GetTripsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-trips"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/trips"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTripsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/trips"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "origin" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "origin",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.UUIDToString(params.Origin))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "destination" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "destination",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.UUIDToString(params.Destination))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "date" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "date",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.Date))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "bicycles" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "bicycles",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Bicycles.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dogs" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dogs",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Dogs.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2"
			switch err := c.securityOAuth2(ctx, GetTripsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeGetTripsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WebhookClient implements webhook client.
type WebhookClient struct {
	baseClient
}

// NewWebhookClient initializes new WebhookClient.
func NewWebhookClient(opts ...ClientOption) (*WebhookClient, error) {
	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &WebhookClient{
		baseClient: c,
	}, nil
}

// NewBooking invokes new-booking operation.
//
// Subscribe to new bookings being created, to update integrations for your users.  Related data is
// available via the links provided in the request.
func (c *WebhookClient) NewBooking(ctx context.Context, targetURL string, request *NewBookingReq, options ...RequestOption) error {
	_, err := c.sendNewBooking(ctx, targetURL, request)
	return err
}

func (c *WebhookClient) sendNewBooking(ctx context.Context, targetURL string, request *NewBookingReq, requestOptions ...RequestOption) (res *NewBookingOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("new-booking"),
		otelogen.WebhookName("newBooking"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NewBookingOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u, err := url.Parse(targetURL)
	if err != nil {
		return res, errors.Wrap(err, "parse target URL")
	}
	if override := reqCfg.ServerURL; override != nil {
		u = uri.Clone(override)
	}
	trimTrailingSlashes(u)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNewBookingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNewBookingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
