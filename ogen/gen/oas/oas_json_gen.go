// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Booking) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Booking) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.TripID.Set {
			e.FieldStart("trip_id")
			s.TripID.Encode(e)
		}
	}
	{
		if s.PassengerName.Set {
			e.FieldStart("passenger_name")
			s.PassengerName.Encode(e)
		}
	}
	{
		if s.HasBicycle.Set {
			e.FieldStart("has_bicycle")
			s.HasBicycle.Encode(e)
		}
	}
	{
		if s.HasDog.Set {
			e.FieldStart("has_dog")
			s.HasDog.Encode(e)
		}
	}
}

var jsonFieldsNameOfBooking = [5]string{
	0: "id",
	1: "trip_id",
	2: "passenger_name",
	3: "has_bicycle",
	4: "has_dog",
}

// Decode decodes Booking from json.
func (s *Booking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Booking to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "trip_id":
			if err := func() error {
				s.TripID.Reset()
				if err := s.TripID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trip_id\"")
			}
		case "passenger_name":
			if err := func() error {
				s.PassengerName.Reset()
				if err := s.PassengerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passenger_name\"")
			}
		case "has_bicycle":
			if err := func() error {
				s.HasBicycle.Reset()
				if err := s.HasBicycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_bicycle\"")
			}
		case "has_dog":
			if err := func() error {
				s.HasDog.Reset()
				if err := s.HasDog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_dog\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Booking")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Booking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Booking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BookingPayment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BookingPayment) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfBookingPayment = [5]string{
	0: "id",
	1: "amount",
	2: "currency",
	3: "source",
	4: "status",
}

// Decode decodes BookingPayment from json.
func (s *BookingPayment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BookingPayment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BookingPayment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BookingPayment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BookingPayment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BookingPaymentCurrency as json.
func (s BookingPaymentCurrency) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BookingPaymentCurrency from json.
func (s *BookingPaymentCurrency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BookingPaymentCurrency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BookingPaymentCurrency(v) {
	case BookingPaymentCurrencyBam:
		*s = BookingPaymentCurrencyBam
	case BookingPaymentCurrencyBgn:
		*s = BookingPaymentCurrencyBgn
	case BookingPaymentCurrencyChf:
		*s = BookingPaymentCurrencyChf
	case BookingPaymentCurrencyEur:
		*s = BookingPaymentCurrencyEur
	case BookingPaymentCurrencyGbp:
		*s = BookingPaymentCurrencyGbp
	case BookingPaymentCurrencyNok:
		*s = BookingPaymentCurrencyNok
	case BookingPaymentCurrencySek:
		*s = BookingPaymentCurrencySek
	case BookingPaymentCurrencyTry:
		*s = BookingPaymentCurrencyTry
	default:
		*s = BookingPaymentCurrency(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BookingPaymentCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BookingPaymentCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BookingPaymentSource as json.
func (s BookingPaymentSource) Encode(e *jx.Encoder) {
	switch s.Type {
	case BookingPaymentSource0BookingPaymentSource:
		s.BookingPaymentSource0.Encode(e)
	case BookingPaymentSource1BookingPaymentSource:
		s.BookingPaymentSource1.Encode(e)
	}
}

func (s BookingPaymentSource) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case BookingPaymentSource0BookingPaymentSource:
		s.BookingPaymentSource0.encodeFields(e)
	case BookingPaymentSource1BookingPaymentSource:
		s.BookingPaymentSource1.encodeFields(e)
	}
}

// Decode decodes BookingPaymentSource from json.
func (s *BookingPaymentSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BookingPaymentSource to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "cvc":
				match := BookingPaymentSource0BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "exp_month":
				match := BookingPaymentSource0BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "exp_year":
				match := BookingPaymentSource0BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address_line1":
				match := BookingPaymentSource0BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address_line2":
				match := BookingPaymentSource0BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address_city":
				match := BookingPaymentSource0BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address_country":
				match := BookingPaymentSource0BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address_post_code":
				match := BookingPaymentSource0BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "sort_code":
				match := BookingPaymentSource1BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "account_type":
				match := BookingPaymentSource1BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "bank_name":
				match := BookingPaymentSource1BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "country":
				match := BookingPaymentSource1BookingPaymentSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case BookingPaymentSource0BookingPaymentSource:
		if err := s.BookingPaymentSource0.Decode(d); err != nil {
			return err
		}
	case BookingPaymentSource1BookingPaymentSource:
		if err := s.BookingPaymentSource1.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BookingPaymentSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BookingPaymentSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BookingPaymentSource0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BookingPaymentSource0) encodeFields(e *jx.Encoder) {
	{
		if s.Object.Set {
			e.FieldStart("object")
			s.Object.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("number")
		e.Str(s.Number)
	}
	{
		e.FieldStart("cvc")
		e.Str(s.Cvc)
	}
	{
		e.FieldStart("exp_month")
		e.Int64(s.ExpMonth)
	}
	{
		e.FieldStart("exp_year")
		e.Int64(s.ExpYear)
	}
	{
		if s.AddressLine1.Set {
			e.FieldStart("address_line1")
			s.AddressLine1.Encode(e)
		}
	}
	{
		if s.AddressLine2.Set {
			e.FieldStart("address_line2")
			s.AddressLine2.Encode(e)
		}
	}
	{
		if s.AddressCity.Set {
			e.FieldStart("address_city")
			s.AddressCity.Encode(e)
		}
	}
	{
		e.FieldStart("address_country")
		e.Str(s.AddressCountry)
	}
	{
		if s.AddressPostCode.Set {
			e.FieldStart("address_post_code")
			s.AddressPostCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfBookingPaymentSource0 = [11]string{
	0:  "object",
	1:  "name",
	2:  "number",
	3:  "cvc",
	4:  "exp_month",
	5:  "exp_year",
	6:  "address_line1",
	7:  "address_line2",
	8:  "address_city",
	9:  "address_country",
	10: "address_post_code",
}

// Decode decodes BookingPaymentSource0 from json.
func (s *BookingPaymentSource0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BookingPaymentSource0 to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Number = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "cvc":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Cvc = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cvc\"")
			}
		case "exp_month":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.ExpMonth = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exp_month\"")
			}
		case "exp_year":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.ExpYear = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exp_year\"")
			}
		case "address_line1":
			if err := func() error {
				s.AddressLine1.Reset()
				if err := s.AddressLine1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address_line1\"")
			}
		case "address_line2":
			if err := func() error {
				s.AddressLine2.Reset()
				if err := s.AddressLine2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address_line2\"")
			}
		case "address_city":
			if err := func() error {
				s.AddressCity.Reset()
				if err := s.AddressCity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address_city\"")
			}
		case "address_country":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AddressCountry = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address_country\"")
			}
		case "address_post_code":
			if err := func() error {
				s.AddressPostCode.Reset()
				if err := s.AddressPostCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address_post_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BookingPaymentSource0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111110,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBookingPaymentSource0) {
					name = jsonFieldsNameOfBookingPaymentSource0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BookingPaymentSource0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BookingPaymentSource0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BookingPaymentSource1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BookingPaymentSource1) encodeFields(e *jx.Encoder) {
	{
		if s.Object.Set {
			e.FieldStart("object")
			s.Object.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("number")
		e.Str(s.Number)
	}
	{
		if s.SortCode.Set {
			e.FieldStart("sort_code")
			s.SortCode.Encode(e)
		}
	}
	{
		e.FieldStart("account_type")
		s.AccountType.Encode(e)
	}
	{
		e.FieldStart("bank_name")
		e.Str(s.BankName)
	}
	{
		e.FieldStart("country")
		e.Str(s.Country)
	}
}

var jsonFieldsNameOfBookingPaymentSource1 = [7]string{
	0: "object",
	1: "name",
	2: "number",
	3: "sort_code",
	4: "account_type",
	5: "bank_name",
	6: "country",
}

// Decode decodes BookingPaymentSource1 from json.
func (s *BookingPaymentSource1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BookingPaymentSource1 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Number = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "sort_code":
			if err := func() error {
				s.SortCode.Reset()
				if err := s.SortCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sort_code\"")
			}
		case "account_type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.AccountType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_type\"")
			}
		case "bank_name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.BankName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bank_name\"")
			}
		case "country":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Country = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BookingPaymentSource1")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01110110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBookingPaymentSource1) {
					name = jsonFieldsNameOfBookingPaymentSource1[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BookingPaymentSource1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BookingPaymentSource1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BookingPaymentSource1AccountType as json.
func (s BookingPaymentSource1AccountType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BookingPaymentSource1AccountType from json.
func (s *BookingPaymentSource1AccountType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BookingPaymentSource1AccountType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BookingPaymentSource1AccountType(v) {
	case BookingPaymentSource1AccountTypeIndividual:
		*s = BookingPaymentSource1AccountTypeIndividual
	case BookingPaymentSource1AccountTypeCompany:
		*s = BookingPaymentSource1AccountTypeCompany
	default:
		*s = BookingPaymentSource1AccountType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BookingPaymentSource1AccountType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BookingPaymentSource1AccountType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BookingPaymentStatus as json.
func (s BookingPaymentStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BookingPaymentStatus from json.
func (s *BookingPaymentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BookingPaymentStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BookingPaymentStatus(v) {
	case BookingPaymentStatusPending:
		*s = BookingPaymentStatusPending
	case BookingPaymentStatusSucceeded:
		*s = BookingPaymentStatusSucceeded
	case BookingPaymentStatusFailed:
		*s = BookingPaymentStatusFailed
	default:
		*s = BookingPaymentStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BookingPaymentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BookingPaymentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateBookingCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateBookingCreated) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.TripID.Set {
			e.FieldStart("trip_id")
			s.TripID.Encode(e)
		}
	}
	{
		if s.PassengerName.Set {
			e.FieldStart("passenger_name")
			s.PassengerName.Encode(e)
		}
	}
	{
		if s.HasBicycle.Set {
			e.FieldStart("has_bicycle")
			s.HasBicycle.Encode(e)
		}
	}
	{
		if s.HasDog.Set {
			e.FieldStart("has_dog")
			s.HasDog.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateBookingCreated = [6]string{
	0: "id",
	1: "trip_id",
	2: "passenger_name",
	3: "has_bicycle",
	4: "has_dog",
	5: "links",
}

// Decode decodes CreateBookingCreated from json.
func (s *CreateBookingCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBookingCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "trip_id":
			if err := func() error {
				s.TripID.Reset()
				if err := s.TripID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trip_id\"")
			}
		case "passenger_name":
			if err := func() error {
				s.PassengerName.Reset()
				if err := s.PassengerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passenger_name\"")
			}
		case "has_bicycle":
			if err := func() error {
				s.HasBicycle.Reset()
				if err := s.HasBicycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_bicycle\"")
			}
		case "has_dog":
			if err := func() error {
				s.HasDog.Reset()
				if err := s.HasDog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_dog\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateBookingCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateBookingCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBookingCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateBookingPaymentOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateBookingPaymentOK) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateBookingPaymentOK = [6]string{
	0: "id",
	1: "amount",
	2: "currency",
	3: "source",
	4: "status",
	5: "links",
}

// Decode decodes CreateBookingPaymentOK from json.
func (s *CreateBookingPaymentOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBookingPaymentOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateBookingPaymentOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateBookingPaymentOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBookingPaymentOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateBookingPaymentOKCurrency as json.
func (s CreateBookingPaymentOKCurrency) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateBookingPaymentOKCurrency from json.
func (s *CreateBookingPaymentOKCurrency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBookingPaymentOKCurrency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateBookingPaymentOKCurrency(v) {
	case CreateBookingPaymentOKCurrencyBam:
		*s = CreateBookingPaymentOKCurrencyBam
	case CreateBookingPaymentOKCurrencyBgn:
		*s = CreateBookingPaymentOKCurrencyBgn
	case CreateBookingPaymentOKCurrencyChf:
		*s = CreateBookingPaymentOKCurrencyChf
	case CreateBookingPaymentOKCurrencyEur:
		*s = CreateBookingPaymentOKCurrencyEur
	case CreateBookingPaymentOKCurrencyGbp:
		*s = CreateBookingPaymentOKCurrencyGbp
	case CreateBookingPaymentOKCurrencyNok:
		*s = CreateBookingPaymentOKCurrencyNok
	case CreateBookingPaymentOKCurrencySek:
		*s = CreateBookingPaymentOKCurrencySek
	case CreateBookingPaymentOKCurrencyTry:
		*s = CreateBookingPaymentOKCurrencyTry
	default:
		*s = CreateBookingPaymentOKCurrency(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateBookingPaymentOKCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBookingPaymentOKCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateBookingPaymentOKSource as json.
func (s CreateBookingPaymentOKSource) Encode(e *jx.Encoder) {
	switch s.Type {
	case CreateBookingPaymentOKSource0CreateBookingPaymentOKSource:
		s.CreateBookingPaymentOKSource0.Encode(e)
	case CreateBookingPaymentOKSource1CreateBookingPaymentOKSource:
		s.CreateBookingPaymentOKSource1.Encode(e)
	}
}

func (s CreateBookingPaymentOKSource) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CreateBookingPaymentOKSource0CreateBookingPaymentOKSource:
		s.CreateBookingPaymentOKSource0.encodeFields(e)
	case CreateBookingPaymentOKSource1CreateBookingPaymentOKSource:
		s.CreateBookingPaymentOKSource1.encodeFields(e)
	}
}

// Decode decodes CreateBookingPaymentOKSource from json.
func (s *CreateBookingPaymentOKSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBookingPaymentOKSource to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "cvc":
				match := CreateBookingPaymentOKSource0CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "exp_month":
				match := CreateBookingPaymentOKSource0CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "exp_year":
				match := CreateBookingPaymentOKSource0CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address_line1":
				match := CreateBookingPaymentOKSource0CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address_line2":
				match := CreateBookingPaymentOKSource0CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address_city":
				match := CreateBookingPaymentOKSource0CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address_country":
				match := CreateBookingPaymentOKSource0CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "address_post_code":
				match := CreateBookingPaymentOKSource0CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "sort_code":
				match := CreateBookingPaymentOKSource1CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "account_type":
				match := CreateBookingPaymentOKSource1CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "bank_name":
				match := CreateBookingPaymentOKSource1CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "country":
				match := CreateBookingPaymentOKSource1CreateBookingPaymentOKSource
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CreateBookingPaymentOKSource0CreateBookingPaymentOKSource:
		if err := s.CreateBookingPaymentOKSource0.Decode(d); err != nil {
			return err
		}
	case CreateBookingPaymentOKSource1CreateBookingPaymentOKSource:
		if err := s.CreateBookingPaymentOKSource1.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateBookingPaymentOKSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBookingPaymentOKSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateBookingPaymentOKSource0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateBookingPaymentOKSource0) encodeFields(e *jx.Encoder) {
	{
		if s.Object.Set {
			e.FieldStart("object")
			s.Object.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("number")
		e.Str(s.Number)
	}
	{
		e.FieldStart("cvc")
		e.Str(s.Cvc)
	}
	{
		e.FieldStart("exp_month")
		e.Int64(s.ExpMonth)
	}
	{
		e.FieldStart("exp_year")
		e.Int64(s.ExpYear)
	}
	{
		if s.AddressLine1.Set {
			e.FieldStart("address_line1")
			s.AddressLine1.Encode(e)
		}
	}
	{
		if s.AddressLine2.Set {
			e.FieldStart("address_line2")
			s.AddressLine2.Encode(e)
		}
	}
	{
		if s.AddressCity.Set {
			e.FieldStart("address_city")
			s.AddressCity.Encode(e)
		}
	}
	{
		e.FieldStart("address_country")
		e.Str(s.AddressCountry)
	}
	{
		if s.AddressPostCode.Set {
			e.FieldStart("address_post_code")
			s.AddressPostCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateBookingPaymentOKSource0 = [11]string{
	0:  "object",
	1:  "name",
	2:  "number",
	3:  "cvc",
	4:  "exp_month",
	5:  "exp_year",
	6:  "address_line1",
	7:  "address_line2",
	8:  "address_city",
	9:  "address_country",
	10: "address_post_code",
}

// Decode decodes CreateBookingPaymentOKSource0 from json.
func (s *CreateBookingPaymentOKSource0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBookingPaymentOKSource0 to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Number = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "cvc":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Cvc = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cvc\"")
			}
		case "exp_month":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.ExpMonth = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exp_month\"")
			}
		case "exp_year":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.ExpYear = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exp_year\"")
			}
		case "address_line1":
			if err := func() error {
				s.AddressLine1.Reset()
				if err := s.AddressLine1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address_line1\"")
			}
		case "address_line2":
			if err := func() error {
				s.AddressLine2.Reset()
				if err := s.AddressLine2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address_line2\"")
			}
		case "address_city":
			if err := func() error {
				s.AddressCity.Reset()
				if err := s.AddressCity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address_city\"")
			}
		case "address_country":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AddressCountry = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address_country\"")
			}
		case "address_post_code":
			if err := func() error {
				s.AddressPostCode.Reset()
				if err := s.AddressPostCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address_post_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateBookingPaymentOKSource0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111110,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateBookingPaymentOKSource0) {
					name = jsonFieldsNameOfCreateBookingPaymentOKSource0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateBookingPaymentOKSource0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBookingPaymentOKSource0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateBookingPaymentOKSource1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateBookingPaymentOKSource1) encodeFields(e *jx.Encoder) {
	{
		if s.Object.Set {
			e.FieldStart("object")
			s.Object.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("number")
		e.Str(s.Number)
	}
	{
		if s.SortCode.Set {
			e.FieldStart("sort_code")
			s.SortCode.Encode(e)
		}
	}
	{
		e.FieldStart("account_type")
		s.AccountType.Encode(e)
	}
	{
		e.FieldStart("bank_name")
		e.Str(s.BankName)
	}
	{
		e.FieldStart("country")
		e.Str(s.Country)
	}
}

var jsonFieldsNameOfCreateBookingPaymentOKSource1 = [7]string{
	0: "object",
	1: "name",
	2: "number",
	3: "sort_code",
	4: "account_type",
	5: "bank_name",
	6: "country",
}

// Decode decodes CreateBookingPaymentOKSource1 from json.
func (s *CreateBookingPaymentOKSource1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBookingPaymentOKSource1 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "object":
			if err := func() error {
				s.Object.Reset()
				if err := s.Object.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Number = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "sort_code":
			if err := func() error {
				s.SortCode.Reset()
				if err := s.SortCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sort_code\"")
			}
		case "account_type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.AccountType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_type\"")
			}
		case "bank_name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.BankName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bank_name\"")
			}
		case "country":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Country = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateBookingPaymentOKSource1")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01110110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateBookingPaymentOKSource1) {
					name = jsonFieldsNameOfCreateBookingPaymentOKSource1[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateBookingPaymentOKSource1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBookingPaymentOKSource1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateBookingPaymentOKSource1AccountType as json.
func (s CreateBookingPaymentOKSource1AccountType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateBookingPaymentOKSource1AccountType from json.
func (s *CreateBookingPaymentOKSource1AccountType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBookingPaymentOKSource1AccountType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateBookingPaymentOKSource1AccountType(v) {
	case CreateBookingPaymentOKSource1AccountTypeIndividual:
		*s = CreateBookingPaymentOKSource1AccountTypeIndividual
	case CreateBookingPaymentOKSource1AccountTypeCompany:
		*s = CreateBookingPaymentOKSource1AccountTypeCompany
	default:
		*s = CreateBookingPaymentOKSource1AccountType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateBookingPaymentOKSource1AccountType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBookingPaymentOKSource1AccountType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateBookingPaymentOKStatus as json.
func (s CreateBookingPaymentOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateBookingPaymentOKStatus from json.
func (s *CreateBookingPaymentOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateBookingPaymentOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateBookingPaymentOKStatus(v) {
	case CreateBookingPaymentOKStatusPending:
		*s = CreateBookingPaymentOKStatusPending
	case CreateBookingPaymentOKStatusSucceeded:
		*s = CreateBookingPaymentOKStatusSucceeded
	case CreateBookingPaymentOKStatusFailed:
		*s = CreateBookingPaymentOKStatusFailed
	default:
		*s = CreateBookingPaymentOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateBookingPaymentOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateBookingPaymentOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBookingOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBookingOK) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.TripID.Set {
			e.FieldStart("trip_id")
			s.TripID.Encode(e)
		}
	}
	{
		if s.PassengerName.Set {
			e.FieldStart("passenger_name")
			s.PassengerName.Encode(e)
		}
	}
	{
		if s.HasBicycle.Set {
			e.FieldStart("has_bicycle")
			s.HasBicycle.Encode(e)
		}
	}
	{
		if s.HasDog.Set {
			e.FieldStart("has_dog")
			s.HasDog.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetBookingOK = [6]string{
	0: "id",
	1: "trip_id",
	2: "passenger_name",
	3: "has_bicycle",
	4: "has_dog",
	5: "links",
}

// Decode decodes GetBookingOK from json.
func (s *GetBookingOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBookingOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "trip_id":
			if err := func() error {
				s.TripID.Reset()
				if err := s.TripID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trip_id\"")
			}
		case "passenger_name":
			if err := func() error {
				s.PassengerName.Reset()
				if err := s.PassengerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passenger_name\"")
			}
		case "has_bicycle":
			if err := func() error {
				s.HasBicycle.Reset()
				if err := s.HasBicycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_bicycle\"")
			}
		case "has_dog":
			if err := func() error {
				s.HasDog.Reset()
				if err := s.HasDog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_dog\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBookingOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBookingOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBookingOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBookingsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBookingsOK) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetBookingsOK = [2]string{
	0: "data",
	1: "links",
}

// Decode decodes GetBookingsOK from json.
func (s *GetBookingsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBookingsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]GetBookingsOKDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetBookingsOKDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBookingsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBookingsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBookingsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBookingsOKDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBookingsOKDataItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.TripID.Set {
			e.FieldStart("trip_id")
			s.TripID.Encode(e)
		}
	}
	{
		if s.PassengerName.Set {
			e.FieldStart("passenger_name")
			s.PassengerName.Encode(e)
		}
	}
	{
		if s.HasBicycle.Set {
			e.FieldStart("has_bicycle")
			s.HasBicycle.Encode(e)
		}
	}
	{
		if s.HasDog.Set {
			e.FieldStart("has_dog")
			s.HasDog.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetBookingsOKDataItem = [5]string{
	0: "id",
	1: "trip_id",
	2: "passenger_name",
	3: "has_bicycle",
	4: "has_dog",
}

// Decode decodes GetBookingsOKDataItem from json.
func (s *GetBookingsOKDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBookingsOKDataItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "trip_id":
			if err := func() error {
				s.TripID.Reset()
				if err := s.TripID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trip_id\"")
			}
		case "passenger_name":
			if err := func() error {
				s.PassengerName.Reset()
				if err := s.PassengerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passenger_name\"")
			}
		case "has_bicycle":
			if err := func() error {
				s.HasBicycle.Reset()
				if err := s.HasBicycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_bicycle\"")
			}
		case "has_dog":
			if err := func() error {
				s.HasDog.Reset()
				if err := s.HasDog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_dog\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBookingsOKDataItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBookingsOKDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBookingsOKDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBookingsOKLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBookingsOKLinks) encodeFields(e *jx.Encoder) {
	{
		if s.Self.Set {
			e.FieldStart("self")
			s.Self.Encode(e)
		}
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetBookingsOKLinks = [3]string{
	0: "self",
	1: "next",
	2: "prev",
}

// Decode decodes GetBookingsOKLinks from json.
func (s *GetBookingsOKLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBookingsOKLinks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := func() error {
				s.Self.Reset()
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBookingsOKLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBookingsOKLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBookingsOKLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStationsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStationsOK) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetStationsOK = [2]string{
	0: "data",
	1: "links",
}

// Decode decodes GetStationsOK from json.
func (s *GetStationsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStationsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]GetStationsOKDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetStationsOKDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStationsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStationsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStationsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStationsOKDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStationsOKDataItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("country_code")
		e.Str(s.CountryCode)
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetStationsOKDataItem = [5]string{
	0: "id",
	1: "name",
	2: "address",
	3: "country_code",
	4: "timezone",
}

// Decode decodes GetStationsOKDataItem from json.
func (s *GetStationsOKDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStationsOKDataItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "country_code":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country_code\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStationsOKDataItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStationsOKDataItem) {
					name = jsonFieldsNameOfGetStationsOKDataItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStationsOKDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStationsOKDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStationsOKLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStationsOKLinks) encodeFields(e *jx.Encoder) {
	{
		if s.Self.Set {
			e.FieldStart("self")
			s.Self.Encode(e)
		}
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetStationsOKLinks = [3]string{
	0: "self",
	1: "next",
	2: "prev",
}

// Decode decodes GetStationsOKLinks from json.
func (s *GetStationsOKLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStationsOKLinks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := func() error {
				s.Self.Reset()
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStationsOKLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStationsOKLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStationsOKLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTripsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTripsOK) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetTripsOK = [2]string{
	0: "data",
	1: "links",
}

// Decode decodes GetTripsOK from json.
func (s *GetTripsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTripsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]GetTripsOKDataItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetTripsOKDataItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTripsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTripsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTripsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTripsOKDataItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTripsOKDataItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Origin.Set {
			e.FieldStart("origin")
			s.Origin.Encode(e)
		}
	}
	{
		if s.Destination.Set {
			e.FieldStart("destination")
			s.Destination.Encode(e)
		}
	}
	{
		if s.DepartureTime.Set {
			e.FieldStart("departure_time")
			s.DepartureTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ArrivalTime.Set {
			e.FieldStart("arrival_time")
			s.ArrivalTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Operator.Set {
			e.FieldStart("operator")
			s.Operator.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.BicyclesAllowed.Set {
			e.FieldStart("bicycles_allowed")
			s.BicyclesAllowed.Encode(e)
		}
	}
	{
		if s.DogsAllowed.Set {
			e.FieldStart("dogs_allowed")
			s.DogsAllowed.Encode(e)
		}
	}
	{
		if s.Self.Set {
			e.FieldStart("self")
			s.Self.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetTripsOKDataItem = [10]string{
	0: "id",
	1: "origin",
	2: "destination",
	3: "departure_time",
	4: "arrival_time",
	5: "operator",
	6: "price",
	7: "bicycles_allowed",
	8: "dogs_allowed",
	9: "self",
}

// Decode decodes GetTripsOKDataItem from json.
func (s *GetTripsOKDataItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTripsOKDataItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "origin":
			if err := func() error {
				s.Origin.Reset()
				if err := s.Origin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"origin\"")
			}
		case "destination":
			if err := func() error {
				s.Destination.Reset()
				if err := s.Destination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination\"")
			}
		case "departure_time":
			if err := func() error {
				s.DepartureTime.Reset()
				if err := s.DepartureTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"departure_time\"")
			}
		case "arrival_time":
			if err := func() error {
				s.ArrivalTime.Reset()
				if err := s.ArrivalTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arrival_time\"")
			}
		case "operator":
			if err := func() error {
				s.Operator.Reset()
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "bicycles_allowed":
			if err := func() error {
				s.BicyclesAllowed.Reset()
				if err := s.BicyclesAllowed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bicycles_allowed\"")
			}
		case "dogs_allowed":
			if err := func() error {
				s.DogsAllowed.Reset()
				if err := s.DogsAllowed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dogs_allowed\"")
			}
		case "self":
			if err := func() error {
				s.Self.Reset()
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTripsOKDataItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTripsOKDataItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTripsOKDataItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTripsOKLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTripsOKLinks) encodeFields(e *jx.Encoder) {
	{
		if s.Self.Set {
			e.FieldStart("self")
			s.Self.Encode(e)
		}
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetTripsOKLinks = [3]string{
	0: "self",
	1: "next",
	2: "prev",
}

// Decode decodes GetTripsOKLinks from json.
func (s *GetTripsOKLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTripsOKLinks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := func() error {
				s.Self.Reset()
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTripsOKLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTripsOKLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTripsOKLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LinksBooking) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LinksBooking) encodeFields(e *jx.Encoder) {
	{
		if s.Booking.Set {
			e.FieldStart("booking")
			s.Booking.Encode(e)
		}
	}
}

var jsonFieldsNameOfLinksBooking = [1]string{
	0: "booking",
}

// Decode decodes LinksBooking from json.
func (s *LinksBooking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinksBooking to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "booking":
			if err := func() error {
				s.Booking.Reset()
				if err := s.Booking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"booking\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinksBooking")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LinksBooking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinksBooking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LinksSelf) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LinksSelf) encodeFields(e *jx.Encoder) {
	{
		if s.Self.Set {
			e.FieldStart("self")
			s.Self.Encode(e)
		}
	}
}

var jsonFieldsNameOfLinksSelf = [1]string{
	0: "self",
}

// Decode decodes LinksSelf from json.
func (s *LinksSelf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinksSelf to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := func() error {
				s.Self.Reset()
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinksSelf")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LinksSelf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinksSelf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewBookingReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewBookingReq) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.TripID.Set {
			e.FieldStart("trip_id")
			s.TripID.Encode(e)
		}
	}
	{
		if s.PassengerName.Set {
			e.FieldStart("passenger_name")
			s.PassengerName.Encode(e)
		}
	}
	{
		if s.HasBicycle.Set {
			e.FieldStart("has_bicycle")
			s.HasBicycle.Encode(e)
		}
	}
	{
		if s.HasDog.Set {
			e.FieldStart("has_dog")
			s.HasDog.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
}

var jsonFieldsNameOfNewBookingReq = [6]string{
	0: "id",
	1: "trip_id",
	2: "passenger_name",
	3: "has_bicycle",
	4: "has_dog",
	5: "links",
}

// Decode decodes NewBookingReq from json.
func (s *NewBookingReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewBookingReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "trip_id":
			if err := func() error {
				s.TripID.Reset()
				if err := s.TripID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trip_id\"")
			}
		case "passenger_name":
			if err := func() error {
				s.PassengerName.Reset()
				if err := s.PassengerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passenger_name\"")
			}
		case "has_bicycle":
			if err := func() error {
				s.HasBicycle.Reset()
				if err := s.HasBicycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_bicycle\"")
			}
		case "has_dog":
			if err := func() error {
				s.HasDog.Reset()
				if err := s.HasDog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_dog\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewBookingReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewBookingReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewBookingReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NewBookingReqLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NewBookingReqLinks) encodeFields(e *jx.Encoder) {
	{
		if s.Self.Set {
			e.FieldStart("self")
			s.Self.Encode(e)
		}
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
}

var jsonFieldsNameOfNewBookingReqLinks = [3]string{
	0: "self",
	1: "next",
	2: "prev",
}

// Decode decodes NewBookingReqLinks from json.
func (s *NewBookingReqLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NewBookingReqLinks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := func() error {
				s.Self.Reset()
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NewBookingReqLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NewBookingReqLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NewBookingReqLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BookingPaymentCurrency as json.
func (o OptBookingPaymentCurrency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BookingPaymentCurrency from json.
func (o *OptBookingPaymentCurrency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBookingPaymentCurrency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBookingPaymentCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBookingPaymentCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BookingPaymentSource as json.
func (o OptBookingPaymentSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BookingPaymentSource from json.
func (o *OptBookingPaymentSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBookingPaymentSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBookingPaymentSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBookingPaymentSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BookingPaymentStatus as json.
func (o OptBookingPaymentStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BookingPaymentStatus from json.
func (o *OptBookingPaymentStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBookingPaymentStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBookingPaymentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBookingPaymentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateBookingPaymentOKCurrency as json.
func (o OptCreateBookingPaymentOKCurrency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateBookingPaymentOKCurrency from json.
func (o *OptCreateBookingPaymentOKCurrency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateBookingPaymentOKCurrency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateBookingPaymentOKCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateBookingPaymentOKCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateBookingPaymentOKSource as json.
func (o OptCreateBookingPaymentOKSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateBookingPaymentOKSource from json.
func (o *OptCreateBookingPaymentOKSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateBookingPaymentOKSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateBookingPaymentOKSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateBookingPaymentOKSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateBookingPaymentOKStatus as json.
func (o OptCreateBookingPaymentOKStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateBookingPaymentOKStatus from json.
func (o *OptCreateBookingPaymentOKStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateBookingPaymentOKStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateBookingPaymentOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateBookingPaymentOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetBookingsOKLinks as json.
func (o OptGetBookingsOKLinks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetBookingsOKLinks from json.
func (o *OptGetBookingsOKLinks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetBookingsOKLinks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetBookingsOKLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetBookingsOKLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetStationsOKLinks as json.
func (o OptGetStationsOKLinks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetStationsOKLinks from json.
func (o *OptGetStationsOKLinks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetStationsOKLinks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetStationsOKLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetStationsOKLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTripsOKLinks as json.
func (o OptGetTripsOKLinks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetTripsOKLinks from json.
func (o *OptGetTripsOKLinks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetTripsOKLinks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetTripsOKLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetTripsOKLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LinksBooking as json.
func (o OptLinksBooking) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LinksBooking from json.
func (o *OptLinksBooking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLinksBooking to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLinksBooking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLinksBooking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LinksSelf as json.
func (o OptLinksSelf) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LinksSelf from json.
func (o *OptLinksSelf) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLinksSelf to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLinksSelf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLinksSelf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NewBookingReqLinks as json.
func (o OptNewBookingReqLinks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NewBookingReqLinks from json.
func (o *OptNewBookingReqLinks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNewBookingReqLinks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNewBookingReqLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNewBookingReqLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Problem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Problem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("instance")
			s.Instance.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfProblem = [5]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "instance",
	4: "status",
}

// Decode decodes Problem from json.
func (s *Problem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Problem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Problem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Problem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Problem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
